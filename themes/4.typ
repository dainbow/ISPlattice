#import "../conf.typ": *

= О LLL

#definition(title: "SVP")[
  Задачей нахождения кратчайшего вектора решётки будем именовать *SVP (Shortest Vector Problem)*

  По заданному базису $B in ZZ^(m times n)$ найти ненулевой вектор $B x$, где $x in ZZ^n without {0}$, такой, что
  #eq[
    $forall y in ZZ^n without {0}: norm(B x) <= norm(B y)$
  ]
]

#definition(title: "CVP")[
  Задачей нахождения ближайшего вектора решётки будем именовать *CVP (Closest Vector Problem)*.

  По заданному базису $B in ZZ^(m times n)$ и вектору-цели $t in ZZ^m$ найти вектор решётки $B x$, такой, что
  #eq[
    $forall y in ZZ^n : norm(B x - t) <= norm(B y - t)$
  ]
]

#definition(title: "Приведённый базис")[
  Пусть $a, b$ -- базис двумерной решётки. Этот базис называется *приведённым* относительно нормы $norm(dot)$, если выполняются неравенства
  #eq[
    $norm(a), norm(b) <= norm(a + b), norm(a - b)$
  ]
]

#definition(title: "Вполне упорядоченный базис")[
  Базис двумерной решётки $a, b$ называется *вполне упорядоченным*, если выполняются неравенства
  #eq[
    $norm(a) <= norm(a - b) < norm(b)$
  ]
]

#theorem(title: "Критерий приведённости")[
  Пусть $a, b$ -- базис двумерной решётки и $lambda_1, lambda_2$ последовательные минимумы решётки.

  Тогда базис $a, b$ приведён тогда и только тогда, когда нормы векторов $a$ и $b$ равны значениями $lambda_1, lambda_2$ соответственно.
]

#definition(title: "Обобщённый алгоритм Гаусса")[
  Вначале определим операцию find(a, b):
  #eq[
    $mu in ZZ : forall mu' in ZZ: norm(b - mu a) <= norm(b - mu' a)$
  ]

  Теперь рассмотрим сам алгоритм:

  Вход: произвольный базис двумерной решётки $(a, b)$

  Выход: приведённый базис
  #eq[
    ```rs
    if norm(a) > norm(b)
        let (a, b) = (b, a);
    if norm(a - b) > norm(a + b)
        let b = -b;
    if norm(b) <= norm(a - b)
        return (a, b);
    if norm(a) <= norm(a - b)
        goto loop;
    if norm(a) = norm(b)
        return (a, a - b);
    let (a, b) = (b - a, b);
    loop {
        let mu = find(a, b);
        let (a, b) = (a, b - mu * a);
        if norm(a - b) > norm(a + b)
            let b = -b;
        let (a, b) = (b, a);

        if приведённый(a, b)
            return (a, b);
    }
    ```]
]

#lemma[
  В начале каждого цикла итераций в алгоритме Гаусса базис $(a, b)$ вполне упорядочен.
]

#lemma[
  Рассмотрим три точки на прямой: $x, x + y, x + alpha y$, где $alpha in (1, +oo)$. Для любой нормы $norm(dot)$:
  #eq[
    $norm(x) <= norm(x + y) => norm(x + y) <= norm(x + alpha y) \
    norm(x) < norm(x + y) => norm(x + y) < norm(x + alpha y)$
  ]
] <lmm:help_norm>

#theorem(title: "Полиномиальность алгоритма Гаусса")[
  Алгоритм Гаусса заканчивает работу за конечное число шагов. Число итераций в алгоритме Гаусса для базиса $(a, b)$ не превосходит $2 + log_2 (norm(a) + norm(b))$
]

#proof[
  Пусть $k$ -- число итераций в алгоритме Гаусса и $(a_k, a_(k + 1))$ -- вполне упорядоченный базис в начале первой итерации.

  Тогда справедлива следующая оценка:
  #eq[
    $forall i >= 3: norm(a_i) < 1 / 2 norm(a_(i + 1))$
  ]
  #proof[
    Рассмотрим последовательность векторов $(a_(i - 1), a_i, a_(i + 1)) = (a, b, c)$.

    Тогда выполняются неравенства
    #eq[
      $norm(a) < norm(b) < norm(c)$
    ]
    и при некотором целом $mu >= 1$ и $epsilon = plus.minus 1$ выполняется равенство $a = epsilon(c - mu b)$. Тогда $c = epsilon a + mu b$. Докажем, что $abs(c) > 2 abs(b)$:
    - Пусть $mu = 1$. Тогда выполняется неравенство $norm(c - b) = norm(a) < norm(b)$, противоречащее вполне упорядоченности базиса $(b, c)$. Следовательно $mu != 1$
    - Пусть $epsilon = - 1, mu = 2$. Тогда $norm(c - b) = norm(-a + b)$. Поскольку базис $(a, b)$ вполне упорядочен, выполняется неравенство $norm(a - b) < norm(b)$ и, следовательно, $norm(c - b) < norm(b) < norm(c)$, что противоречит упорядоченности базиса $(b, c)$.
    - Пусть $epsilon = -1, mu > 2$. Тогда, учитывая неравенство $norm(a) < norm(b)$, получим
    #eq[
      $norm(c) = norm(-a + mu b) >= mu norm(b) - norm(a) > mu norm(b) - norm(b) = (mu - 1) norm(b) >= 2 norm(b)$
    ]
    - Пусть $epsilon = 1, mu >= 2$. Поскольку базис $(a, b)$ вполне упорядочен, выполняется неравенство $norm(b - a) < norm(b)$. Тогда по @lmm:help_norm, выполняется неравенство $norm(b) < norm(b + a)$, а из упорядоченности базиса $(a, b)$ следует неравенство $norm(a) <= norm(b - a)$, поэтому $norm(a) < norm(b + 1)$.

    Наконец, используя @lmm:help_norm получим
    #eq[
      $norm(a) <= norm(a + b) < norm(a + 2 b) <= norm(a + mu b) = c$
    ]
    Итак, доказано неравенство $norm(c) = norm(a + mu b) >= norm(2 b + a)$. Для доказательства леммы достаточно проверить выполнение неравенства $norm(2 b + a) > 2 norm(b)$.

    Используя неравенство $norm(a - b) < b$ (упорядоченность $(a, b)$), из неравенства треугольника получаем
    #eq[
      $norm(2 b - a) <= norm(b) + norm(b - a) < norm(b) + norm(b) = 2 norm(b)$
    ]
    Снова воспользовавшись @lmm:help_norm:
    #eq[
      $norm(2 b - a) < norm(2 b) = norm(2 b - a + a) < norm(2 b - a + 2 a) = norm(2 b + a)$
    ]
  ]

  Воспользовавшись леммой, получаем, что при $i >= 3$ выполняется неравенство
  #eq[
    $norm(a_i) >= 2^(i - 3) norm(a_3)$
  ]
  В частности, для любых базисных векторов $a, b$ выполняется неравенство
  #eq[
    $norm(a) + norm(b) >= norm(a_(k + 1)) >= 2^(k - 2) norm(a_3) >= 2^(k - 2)$
  ]
  Следовательно, $k <= 2 + log_2 (norm(a) + norm(b))$
]

#definition(title: "LLL-приведённый базис")[
  Базис $B = (b_1, ..., b_n) in RR^(m times n)$ называется LLL-приведённым, относительно параметра $1 / 4 < delta < 1$, если
  + $mu_(i j) <= 1 / 2$ при $i > j$, где $mu_(i j)$ -- коэффициенты матрицы ортогонализации Грамма-Шмидта
  + Для любой последовательной пары векторов $b_i, b_(i + 1)$ выполняется неравенство
  #eq[
    $delta norm(pi_i (b_i))^2 <= norm(pi_i (b_(i + 1)))^2$
  ]
  где $pi_i$ -- проекция на линейную оболочку $angle.l b_i^*, ..., b_n^* angle.r$.

  Иначе это условие задаётся соотношением
  #eq[
    $delta norm(b_i^*)^2 <= norm(b_(i + 1)^* + mu_(i + 1, i)b_i^*)^2 = norm(b_(i + 1)^*)^2 + mu_(i + 1, i)^2 norm(b_i^*)^2$
  ]
] <lll-came-basis>

#theorem(title: "Свойства LLL-приведённого базиса")[
  Пусть $b_1, ..., b_n$ -- LLL-приведённый базис решётки $L$. Тогда
  + $det L <= product_(i = 1)^n norm(b_i) <= (4 / (4 delta - 1))^((n (n - 1)) / 4) det L$
  + $norm(b_j) <= (4 / (4 delta - 1))^((i - 1) / 2) norm(b_i^*)$ при $1 <= j <= i <= n$
  + $norm(b_1) <= (4 / (4 delta - 1))^((n - 1) / 4) (det L)^(1 / n)$
  + Если $x != 0$ -- элемент решётки, то $norm(b_1) <= (4 / (4 delta - 1))^((n - 1) / 2) norm(x)$
]

#definition(title: "LLL-алгоритм")[
  Вход: Базис решётки $B = (b_1, ..., b_n) in ZZ^(m times n)$

  Выход: LLL-приведённый базис решётки

  #figure(image("../assets/lll.png"))
]

#proposition[
  LLL-алгоритм корректен и работает за полиномиальное количество шагов
]

#proof[
  Определим целые числа $d_i$ формулой:
  #eq[
    $d_i (b) = det mat(
      (b_1, b_1), ..., (b_1, b_i);
      ..., dots.down, ...;
      (b_i, b_1), ..., (b_i, b_i)
    )$
  ]
  Согласно доказанному ранее об объёме основного параллелепипеда, выполняется равенство
  #eq[
    $d_i (b) = product_(j = 1)^n norm(b_j^*)^2$
  ]

  Введём также обозначение
  #eq[
    $D(b) = product_(j = 1)^(n - 1) d_j (b)$
  ]
  Заметим, что если в процессе выполнения алгоритма не выполняется перестановка векторов, то величины $d_i$, являющиеся детерминантами базисов соответствующих решёток, не изменяются. Следовательно, и величина $D$ в этом случае не изменяется.

  Рассмотрим теперь шаг алгоритма, на котором выполняется перестановка двух соседних элементов базиса. А именно, пусть векторы $b_1, ..., b_i$ определяют LLL-приведённый базис в решётке $angle.l b_1, ..., b_i angle.r$, порождённой этими векторами.

  Пусть также векторы $b_1, ..., b_(i + 1)$ представляют базис, для которого выполняется условие 1, но не выполняется условие 2 @lll-came-basis.

  Тогда, согласно LLL-алгоритму, выполняется перестановка векторов $b_i, b_(i + 1)$. Назовём новый базис $tilde(b)$.

  Посмотрим, как изменится при этом значение величины $D$. Отметим, что значения $d_k, k != i$ остаются неизменными. Запишем соответствующее преобразование базиса
  #eq[
    $(tilde(b_1), ..., tilde(b_i)) = (b_1, ..., b_(i + 1), b_i)$
  ]
  поэтому
  #eq[
    $D(tilde(b)) / D(b) = product_(k = 1)^n (d_k (tilde(b))) / (d_k (b)) = (d_i (tilde(b))) / (d_i (b)) = norm(pi_i (b_(i + 1)))^2 / norm(b_i^*)^2$
  ]
  Поскольку выполнилась перестановка, второе условие @lll-came-basis не выполняется, то есть
  #eq[
    $norm(pi_i (b_(i + 1)))^2 / norm(b_i^*)^2= norm(pi_i (b_(i + 1)))^2 / norm(pi_i (b_i))^2 <= delta$
  ]
  Поэтому выполняется неравенство
  #eq[
    $D (tilde(b)) <= delta D(b)$
  ]
  Пусть $D_0 = D(d_1, ..., d_n)$ -- значение целозначной функции $D$ на исходном базисе решётки на входе LLL-алгоритма, а $D_k$ -- соответствующее значение после $k$-й итерации.

  Тогда из формулы выше следует соотношение $D_k <= delta^k D_0$.

  Поскольку $D$ -- целозначная положительная функция и $delta < 1$, выполняется неравенство
  #eq[
    $k <= (log D_0) / (log (1 / delta))$
  ]
  Следовательно, если $delta < 1$ -- константа, то число итераций полиномиально от длины входа.
]

#pagebreak()
